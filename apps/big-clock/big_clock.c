/**
 * @file big_clock.c
 * @brief Big Clock - Full-screen digital clock for Flipper Zero
 *
 * A bedside/tableside clock application featuring:
 * - Large 24x48 pixel custom digits
 * - Adjustable brightness (0-100% in 10% steps)
 * - Always-on backlight with manual brightness control
 *
 * @author Eris Margeta (@Eris-Margeta)
 * @license MIT
 * @version 1.1
 *
 * SPDX-License-Identifier: MIT
 */

#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <input/input.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>

/* ============================================================================
 * INTERNAL NOTIFICATION STRUCTURES
 * ============================================================================
 * These structures are defined here to access internal notification settings
 * for flicker-free brightness control (same approach as NightStand Clock).
 * Based on flipperdevices/flipperzero-firmware notification_app.h
 */

typedef struct {
    uint8_t value_last[2];
    uint8_t value[2];
    uint8_t index;
    uint8_t light;
} NotificationLedLayer;

typedef struct {
    uint8_t version;
    float display_brightness;
    float led_brightness;
    float speaker_volume;
    uint32_t display_off_delay_ms;
    int8_t contrast;
    bool vibro_on;
} NotificationSettings;

typedef struct {
    FuriMessageQueue* queue;
    FuriPubSub* event_record;
    FuriTimer* display_timer;
    NotificationLedLayer display;
    NotificationLedLayer led[3];
    uint8_t display_led_lock;
    NotificationSettings settings;
} NotificationAppInternal;

/* ============================================================================
 * CONSTANTS
 * ============================================================================ */

/** Digit bitmap dimensions */
#define DIGIT_WIDTH          24
#define DIGIT_HEIGHT         48
#define DIGIT_BYTES_PER_ROW  3

/** Colon dimensions */
#define COLON_WIDTH          8
#define COLON_DOT_SIZE       4
#define COLON_TOP_OFFSET     14
#define COLON_BOTTOM_OFFSET  30
#define COLON_X_OFFSET       2

/** Screen dimensions */
#define SCREEN_WIDTH         128
#define SCREEN_HEIGHT        64

/** Brightness control */
#define BRIGHTNESS_MIN       0
#define BRIGHTNESS_MAX       100
#define BRIGHTNESS_STEP      5
#define BRIGHTNESS_DISPLAY_MS 500  /* milliseconds to show brightness indicator after change */

/** Layout calculations */
#define CLOCK_TOTAL_WIDTH    (4 * DIGIT_WIDTH + COLON_WIDTH)  /* 104 pixels */
#define CLOCK_START_X        ((SCREEN_WIDTH - CLOCK_TOTAL_WIDTH) / 2)

/** Input handling */
#define INPUT_QUEUE_SIZE     8
#define UPDATE_INTERVAL_MS   60000  /* 60 seconds - power efficient since we only show HH:MM */

/* ============================================================================
 * TYPES
 * ============================================================================ */

/**
 * @brief Application state structure
 *
 * Holds all mutable state for the clock application.
 */
typedef struct {
    uint8_t hour;                    /**< Current hour (0-23) */
    uint8_t minute;                  /**< Current minute (0-59) */
    uint8_t brightness;              /**< Brightness level (0-100) */
    uint32_t brightness_show_until;  /**< Timestamp until which to show brightness UI */
    bool is_running;                 /**< Application run state */
    NotificationAppInternal* notification; /**< Notification service handle (internal cast) */
    float original_brightness;       /**< Saved brightness to restore on exit */
} BigClockState;

/* ============================================================================
 * DIGIT BITMAP DATA
 * ============================================================================
 *
 * Each digit is a 24x48 pixel bitmap stored as 3 bytes per row (24 bits).
 * Total size per digit: 48 rows * 3 bytes = 144 bytes.
 *
 * Bit ordering: MSB first (bit 7 = leftmost pixel)
 * 1 = pixel on (white), 0 = pixel off (black)
 */

static const uint8_t digit_bitmap_0[] = {
    0x07, 0xFF, 0xE0, 0x1F, 0xFF, 0xF8, 0x3F, 0xFF, 0xFC, 0x7F, 0xFF, 0xFE,
    0x7E, 0x00, 0x7E, 0xFC, 0x00, 0x3F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xFC, 0x00, 0x3F,
    0x7E, 0x00, 0x7E, 0x7F, 0xFF, 0xFE, 0x3F, 0xFF, 0xFC, 0x1F, 0xFF, 0xF8,
    0x07, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t digit_bitmap_1[] = {
    0x00, 0x1F, 0x00, 0x00, 0x3F, 0x00, 0x00, 0xFF, 0x00, 0x03, 0xFF, 0x00,
    0x0F, 0xFF, 0x00, 0x1F, 0xFF, 0x00, 0x1F, 0x1F, 0x00, 0x1C, 0x1F, 0x00,
    0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x1F, 0x00, 0x0F, 0xFF, 0xF0, 0x0F, 0xFF, 0xF0, 0x0F, 0xFF, 0xF0,
    0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t digit_bitmap_2[] = {
    0x07, 0xFF, 0xE0, 0x1F, 0xFF, 0xF8, 0x3F, 0xFF, 0xFC, 0x7F, 0xFF, 0xFE,
    0x7E, 0x00, 0x7E, 0xFC, 0x00, 0x3F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x3F, 0x00, 0x00, 0x7E, 0x00, 0x00, 0xFC, 0x00, 0x01, 0xF8,
    0x00, 0x03, 0xF0, 0x00, 0x07, 0xE0, 0x00, 0x0F, 0xC0, 0x00, 0x1F, 0x80,
    0x00, 0x3F, 0x00, 0x00, 0x7E, 0x00, 0x00, 0xFC, 0x00, 0x01, 0xF8, 0x00,
    0x03, 0xF0, 0x00, 0x07, 0xE0, 0x00, 0x0F, 0xC0, 0x00, 0x1F, 0x80, 0x00,
    0x3F, 0x00, 0x00, 0x7E, 0x00, 0x00, 0xFC, 0x00, 0x00, 0xF8, 0x00, 0x00,
    0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00,
    0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xFC, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t digit_bitmap_3[] = {
    0x07, 0xFF, 0xE0, 0x1F, 0xFF, 0xF8, 0x3F, 0xFF, 0xFC, 0x7F, 0xFF, 0xFE,
    0x7E, 0x00, 0x7E, 0xFC, 0x00, 0x3F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x7E,
    0x00, 0x00, 0xFC, 0x00, 0xFF, 0xF8, 0x00, 0xFF, 0xF0, 0x00, 0xFF, 0xF8,
    0x00, 0x00, 0xFC, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xFC, 0x00, 0x3F, 0x7E, 0x00, 0x7E, 0x7F, 0xFF, 0xFE,
    0x3F, 0xFF, 0xFC, 0x1F, 0xFF, 0xF8, 0x07, 0xFF, 0xE0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t digit_bitmap_4[] = {
    0x00, 0x01, 0xF8, 0x00, 0x03, 0xF8, 0x00, 0x07, 0xF8, 0x00, 0x0F, 0xF8,
    0x00, 0x1F, 0xF8, 0x00, 0x3E, 0xF8, 0x00, 0x7C, 0xF8, 0x00, 0xF8, 0xF8,
    0x01, 0xF0, 0xF8, 0x03, 0xE0, 0xF8, 0x07, 0xC0, 0xF8, 0x0F, 0x80, 0xF8,
    0x1F, 0x00, 0xF8, 0x3E, 0x00, 0xF8, 0x7C, 0x00, 0xF8, 0xF8, 0x00, 0xF8,
    0xF8, 0x00, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x00, 0xF8,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8,
    0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8,
    0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8,
    0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8,
    0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t digit_bitmap_5[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00,
    0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00,
    0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00,
    0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0xFE,
    0x00, 0x00, 0x7E, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xFC, 0x00, 0x3F, 0x7E, 0x00, 0x7E, 0x7F, 0xFF, 0xFE,
    0x3F, 0xFF, 0xFC, 0x1F, 0xFF, 0xF8, 0x07, 0xFF, 0xE0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t digit_bitmap_6[] = {
    0x07, 0xFF, 0xE0, 0x1F, 0xFF, 0xF8, 0x3F, 0xFF, 0xFC, 0x7F, 0xFF, 0xFE,
    0x7E, 0x00, 0x7E, 0xFC, 0x00, 0x3F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00,
    0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00,
    0xF8, 0x00, 0x00, 0xF9, 0xFF, 0xE0, 0xFB, 0xFF, 0xF8, 0xFF, 0xFF, 0xFC,
    0xFF, 0xFF, 0xFE, 0xFE, 0x00, 0x7E, 0xFC, 0x00, 0x3F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xFC, 0x00, 0x3F, 0x7E, 0x00, 0x7E, 0x7F, 0xFF, 0xFE,
    0x3F, 0xFF, 0xFC, 0x1F, 0xFF, 0xF8, 0x07, 0xFF, 0xE0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t digit_bitmap_7[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3E,
    0x00, 0x00, 0x7E, 0x00, 0x00, 0x7C, 0x00, 0x00, 0xFC, 0x00, 0x00, 0xF8,
    0x00, 0x01, 0xF8, 0x00, 0x01, 0xF0, 0x00, 0x03, 0xF0, 0x00, 0x03, 0xE0,
    0x00, 0x07, 0xE0, 0x00, 0x07, 0xC0, 0x00, 0x0F, 0xC0, 0x00, 0x0F, 0x80,
    0x00, 0x1F, 0x80, 0x00, 0x1F, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3E, 0x00,
    0x00, 0x7E, 0x00, 0x00, 0x7C, 0x00, 0x00, 0xFC, 0x00, 0x00, 0xF8, 0x00,
    0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00,
    0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00,
    0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00,
    0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t digit_bitmap_8[] = {
    0x07, 0xFF, 0xE0, 0x1F, 0xFF, 0xF8, 0x3F, 0xFF, 0xFC, 0x7F, 0xFF, 0xFE,
    0x7E, 0x00, 0x7E, 0xFC, 0x00, 0x3F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xFC, 0x00, 0x3F, 0x7E, 0x00, 0x7E,
    0x3F, 0xFF, 0xFC, 0x1F, 0xFF, 0xF8, 0x1F, 0xFF, 0xF8, 0x3F, 0xFF, 0xFC,
    0x7E, 0x00, 0x7E, 0xFC, 0x00, 0x3F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xFC, 0x00, 0x3F, 0x7E, 0x00, 0x7E, 0x7F, 0xFF, 0xFE,
    0x3F, 0xFF, 0xFC, 0x1F, 0xFF, 0xF8, 0x07, 0xFF, 0xE0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t digit_bitmap_9[] = {
    0x07, 0xFF, 0xE0, 0x1F, 0xFF, 0xF8, 0x3F, 0xFF, 0xFC, 0x7F, 0xFF, 0xFE,
    0x7E, 0x00, 0x7E, 0xFC, 0x00, 0x3F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xFC, 0x00, 0x3F, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF,
    0x3F, 0xFF, 0xFF, 0x1F, 0xFF, 0xDF, 0x07, 0xFF, 0x9F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F,
    0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x1F, 0xF8, 0x00, 0x1F,
    0xF8, 0x00, 0x1F, 0xFC, 0x00, 0x3F, 0x7E, 0x00, 0x7E, 0x7F, 0xFF, 0xFE,
    0x3F, 0xFF, 0xFC, 0x1F, 0xFF, 0xF8, 0x07, 0xFF, 0xE0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

/** Lookup table for digit bitmaps (0-9) */
static const uint8_t* const digit_bitmaps[10] = {
    digit_bitmap_0, digit_bitmap_1, digit_bitmap_2, digit_bitmap_3, digit_bitmap_4,
    digit_bitmap_5, digit_bitmap_6, digit_bitmap_7, digit_bitmap_8, digit_bitmap_9
};

/* ============================================================================
 * DRAWING FUNCTIONS
 * ============================================================================ */

/**
 * @brief Draw a single digit at the specified position
 *
 * Renders a 24x48 pixel digit bitmap to the canvas.
 *
 * @param canvas    Canvas to draw on
 * @param digit     Digit value (0-9)
 * @param x         X coordinate (left edge)
 * @param y         Y coordinate (top edge)
 */
static void draw_digit(Canvas* canvas, uint8_t digit, int16_t x, int16_t y) {
    /* Validate digit range */
    if(digit > 9) {
        return;
    }

    const uint8_t* bitmap = digit_bitmaps[digit];

    /* Iterate through each pixel in the bitmap */
    for(int16_t row = 0; row < DIGIT_HEIGHT; row++) {
        for(int16_t col = 0; col < DIGIT_WIDTH; col++) {
            /* Calculate byte and bit position */
            int16_t byte_index = row * DIGIT_BYTES_PER_ROW + col / 8;
            int16_t bit_index = 7 - (col % 8);

            /* Draw pixel if bit is set */
            if(bitmap[byte_index] & (1 << bit_index)) {
                canvas_draw_dot(canvas, x + col, y + row);
            }
        }
    }
}

/**
 * @brief Draw the colon separator between hours and minutes
 *
 * Renders two square dots vertically centered.
 *
 * @param canvas    Canvas to draw on
 * @param x         X coordinate (left edge)
 * @param y         Y coordinate (top of digit area)
 */
static void draw_colon(Canvas* canvas, int16_t x, int16_t y) {
    int16_t top_dot_y = y + COLON_TOP_OFFSET;
    int16_t bottom_dot_y = y + COLON_BOTTOM_OFFSET;

    canvas_draw_box(canvas, x + COLON_X_OFFSET, top_dot_y, COLON_DOT_SIZE, COLON_DOT_SIZE);
    canvas_draw_box(canvas, x + COLON_X_OFFSET, bottom_dot_y, COLON_DOT_SIZE, COLON_DOT_SIZE);
}

/**
 * @brief Draw the brightness indicator UI
 *
 * Shows current brightness percentage and a progress bar.
 *
 * @param canvas      Canvas to draw on
 * @param brightness  Current brightness level (0-100)
 */
static void draw_brightness_indicator(Canvas* canvas, uint8_t brightness) {
    /* Draw brightness text at top */
    canvas_set_font(canvas, FontSecondary);

    char text_buffer[20];
    snprintf(text_buffer, sizeof(text_buffer), "Brightness: %d%%", brightness);
    canvas_draw_str_aligned(canvas, SCREEN_WIDTH / 2, 2, AlignCenter, AlignTop, text_buffer);

    /* Draw progress bar at bottom */
    const int16_t bar_x = 14;
    const int16_t bar_y = 56;
    const int16_t bar_width = 100;
    const int16_t bar_height = 6;

    /* Bar outline */
    canvas_draw_frame(canvas, bar_x, bar_y, bar_width, bar_height);

    /* Filled portion */
    if(brightness > 0) {
        int16_t fill_width = brightness - 1;
        if(fill_width > 0) {
            canvas_draw_box(canvas, bar_x + 1, bar_y + 1, fill_width, bar_height - 2);
        }
    }
}

/* ============================================================================
 * CALLBACK FUNCTIONS
 * ============================================================================ */

/**
 * @brief Render callback - draws the clock display
 *
 * Called by the GUI system when the screen needs updating.
 *
 * @param canvas  Canvas to draw on
 * @param ctx     Context pointer (BigClockState*)
 */
static void render_callback(Canvas* canvas, void* ctx) {
    BigClockState* state = (BigClockState*)ctx;

    canvas_clear(canvas);

    /* Calculate vertical center position */
    int16_t y = (SCREEN_HEIGHT - DIGIT_HEIGHT) / 2;
    int16_t x = CLOCK_START_X;

    /* Draw hours */
    draw_digit(canvas, state->hour / 10, x, y);
    x += DIGIT_WIDTH;
    draw_digit(canvas, state->hour % 10, x, y);
    x += DIGIT_WIDTH;

    /* Draw colon separator */
    draw_colon(canvas, x, y);
    x += COLON_WIDTH;

    /* Draw minutes */
    draw_digit(canvas, state->minute / 10, x, y);
    x += DIGIT_WIDTH;
    draw_digit(canvas, state->minute % 10, x, y);

    /* Show brightness indicator if recently changed (timestamp-based) */
    if(furi_get_tick() < state->brightness_show_until) {
        draw_brightness_indicator(canvas, state->brightness);
    }
}

/**
 * @brief Input callback - handles button events
 *
 * Called by the GUI system when input events occur.
 * Events are forwarded to the main loop via message queue.
 *
 * @param input_event  Input event data
 * @param ctx          Context pointer (FuriMessageQueue*)
 */
static void input_callback(InputEvent* input_event, void* ctx) {
    FuriMessageQueue* event_queue = (FuriMessageQueue*)ctx;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

/* ============================================================================
 * BACKLIGHT CONTROL
 * ============================================================================ */

/**
 * @brief Set backlight brightness via notification settings
 *
 * Uses the NightStand Clock approach: directly modifies the notification
 * app's internal brightness setting, then triggers a backlight update.
 * This avoids flickering because the system uses our value instead of
 * overriding it.
 *
 * @param state       Application state (contains notification handle)
 * @param brightness  Brightness percentage (0-100)
 */
static void backlight_set_brightness(BigClockState* state, uint8_t brightness) {
    /* Clamp to valid range */
    if(brightness > BRIGHTNESS_MAX) {
        brightness = BRIGHTNESS_MAX;
    }

    /* Set brightness in notification settings (0.0 - 1.0) */
    state->notification->settings.display_brightness = (float)brightness / 100.0f;

    /* Trigger backlight update with new brightness value */
    notification_message((NotificationApp*)state->notification, &sequence_display_backlight_on);
}

/* ============================================================================
 * INPUT HANDLING
 * ============================================================================ */

/**
 * @brief Increase brightness by one step
 *
 * @param state  Application state
 */
static void brightness_increase(BigClockState* state) {
    if(state->brightness < BRIGHTNESS_MAX) {
        state->brightness += BRIGHTNESS_STEP;
        if(state->brightness > BRIGHTNESS_MAX) {
            state->brightness = BRIGHTNESS_MAX;
        }
        backlight_set_brightness(state, state->brightness);
        state->brightness_show_until = furi_get_tick() + BRIGHTNESS_DISPLAY_MS;
    }
}

/**
 * @brief Decrease brightness by one step
 *
 * @param state  Application state
 */
static void brightness_decrease(BigClockState* state) {
    if(state->brightness >= BRIGHTNESS_STEP) {
        state->brightness -= BRIGHTNESS_STEP;
        backlight_set_brightness(state, state->brightness);
        state->brightness_show_until = furi_get_tick() + BRIGHTNESS_DISPLAY_MS;
    }
}

/**
 * @brief Process input event
 *
 * @param state  Application state
 * @param event  Input event to process
 */
static void process_input(BigClockState* state, InputEvent* event) {
    /* Only handle press and repeat events */
    if(event->type != InputTypePress && event->type != InputTypeRepeat) {
        return;
    }

    switch(event->key) {
        case InputKeyUp:
            brightness_increase(state);
            break;

        case InputKeyDown:
            brightness_decrease(state);
            break;

        case InputKeyBack:
            state->is_running = false;
            break;

        default:
            /* Ignore other keys */
            break;
    }
}

/* ============================================================================
 * TIME MANAGEMENT
 * ============================================================================ */

/**
 * @brief Update state with current time from RTC
 *
 * @param state  Application state to update
 */
static void update_time(BigClockState* state) {
    DateTime datetime;
    furi_hal_rtc_get_datetime(&datetime);

    state->hour = datetime.hour;
    state->minute = datetime.minute;
}

/* ============================================================================
 * APPLICATION LIFECYCLE
 * ============================================================================ */

/**
 * @brief Initialize application state
 *
 * @return Pointer to allocated and initialized state
 */
static BigClockState* state_alloc(void) {
    BigClockState* state = malloc(sizeof(BigClockState));

    state->hour = 0;
    state->minute = 0;
    state->brightness = BRIGHTNESS_MAX;
    state->brightness_show_until = 0;
    state->is_running = true;
    state->notification = NULL;
    state->original_brightness = 1.0f;

    return state;
}

/**
 * @brief Free application state
 *
 * @param state  State to free
 */
static void state_free(BigClockState* state) {
    free(state);
}

/**
 * @brief Main application entry point
 *
 * @param p  Unused parameter
 * @return   Exit code (0 = success)
 */
int32_t big_clock_app(void* p) {
    UNUSED(p);

    /* Initialize state */
    BigClockState* state = state_alloc();

    /* Create input event queue */
    FuriMessageQueue* event_queue = furi_message_queue_alloc(INPUT_QUEUE_SIZE, sizeof(InputEvent));

    /* Set up viewport */
    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, render_callback, state);
    view_port_input_callback_set(view_port, input_callback, event_queue);

    /* Register with GUI */
    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    /* Open notification service and cast to internal type for brightness access */
    state->notification = (NotificationAppInternal*)furi_record_open(RECORD_NOTIFICATION);

    /* Save original brightness and use it as our starting point (don't override system setting) */
    state->original_brightness = state->notification->settings.display_brightness;

    /* Convert system brightness (0.0-1.0) to our percentage (0-100), rounded to nearest 10% step */
    uint8_t system_brightness_pct = (uint8_t)(state->original_brightness * 100.0f);
    state->brightness = (system_brightness_pct / BRIGHTNESS_STEP) * BRIGHTNESS_STEP;
    if(state->brightness > BRIGHTNESS_MAX) state->brightness = BRIGHTNESS_MAX;

    /* Enable always-on backlight (keeps current brightness, just prevents auto-off) */
    notification_message((NotificationApp*)state->notification, &sequence_display_backlight_enforce_on);

    /* Get initial time */
    update_time(state);

    /* Briefly flash brightness indicator so user knows current level (2 seconds) */
    state->brightness_show_until = furi_get_tick() + 2000;
    view_port_update(view_port);

    /* Main loop */
    InputEvent event;

    while(state->is_running) {
        /* Update current time */
        update_time(state);

        /*
         * Reapply brightness every update cycle to prevent firmware from reverting it.
         * The notification system has an internal timer that can reset brightness
         * to system defaults after a timeout period (~1 hour). By reapplying every
         * 60 seconds (when we update the display anyway), we ensure our brightness
         * setting persists while remaining power efficient.
         */
        backlight_set_brightness(state, state->brightness);

        /* Request screen redraw */
        view_port_update(view_port);

        /* Process input events (with timeout for periodic updates) */
        if(furi_message_queue_get(event_queue, &event, UPDATE_INTERVAL_MS) == FuriStatusOk) {
            process_input(state, &event);
            /* Immediate redraw after input to show brightness indicator */
            view_port_update(view_port);
        }
    }

    /* Cleanup: restore original brightness and default backlight behavior */
    state->notification->settings.display_brightness = state->original_brightness;
    notification_message((NotificationApp*)state->notification, &sequence_display_backlight_enforce_auto);
    furi_record_close(RECORD_NOTIFICATION);

    /* Remove from GUI */
    gui_remove_view_port(gui, view_port);
    furi_record_close(RECORD_GUI);

    /* Free resources */
    view_port_free(view_port);
    furi_message_queue_free(event_queue);
    state_free(state);

    return 0;
}
